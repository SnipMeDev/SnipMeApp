// Autogenerated from Pigeon (v4.2.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

enum SnippetLanguageType {
  c,
  cpp,
  objectiveC,
  cSharp,
  java,
  bash,
  python,
  perl,
  ruby,
  swift,
  javascript,
  kotlin,
  coffeescript,
  rust,
  basic,
  clojure,
  css,
  dart,
  erlang,
  go,
  haskell,
  lisp,
  llvm,
  lua,
  matlab,
  ml,
  mumps,
  nemerle,
  pascal,
  r,
  rd,
  scala,
  sql,
  tex,
  vb,
  vhdl,
  tcl,
  xquery,
  yaml,
  markdown,
  json,
  xml,
  proto,
  regex,
  unknown,
}

enum SnippetFilterType {
  all,
  mine,
  shared,
}

enum UserReaction {
  none,
  like,
  dislike,
}

enum ModelState {
  loading,
  loaded,
  error,
}

enum MainModelEvent {
  none,
  alert,
  logout,
}

enum DetailModelEvent {
  none,
  saved,
  deleted,
}

enum LoginModelEvent {
  none,
  logged,
}

class Snippet {
  Snippet({
    this.uuid,
    this.title,
    this.code,
    this.language,
    this.owner,
    this.isOwner,
    this.timeAgo,
    this.voteResult,
    this.userReaction,
    this.isPrivate,
    this.isLiked,
    this.isDisliked,
    this.isSaved,
    this.isToDelete,
  });

  String? uuid;
  String? title;
  SnippetCode? code;
  SnippetLanguage? language;
  Owner? owner;
  bool? isOwner;
  String? timeAgo;
  int? voteResult;
  UserReaction? userReaction;
  bool? isPrivate;
  bool? isLiked;
  bool? isDisliked;
  bool? isSaved;
  bool? isToDelete;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['uuid'] = uuid;
    pigeonMap['title'] = title;
    pigeonMap['code'] = code?.encode();
    pigeonMap['language'] = language?.encode();
    pigeonMap['owner'] = owner?.encode();
    pigeonMap['isOwner'] = isOwner;
    pigeonMap['timeAgo'] = timeAgo;
    pigeonMap['voteResult'] = voteResult;
    pigeonMap['userReaction'] = userReaction?.index;
    pigeonMap['isPrivate'] = isPrivate;
    pigeonMap['isLiked'] = isLiked;
    pigeonMap['isDisliked'] = isDisliked;
    pigeonMap['isSaved'] = isSaved;
    pigeonMap['isToDelete'] = isToDelete;
    return pigeonMap;
  }

  static Snippet decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Snippet(
      uuid: pigeonMap['uuid'] as String?,
      title: pigeonMap['title'] as String?,
      code: pigeonMap['code'] != null
          ? SnippetCode.decode(pigeonMap['code']!)
          : null,
      language: pigeonMap['language'] != null
          ? SnippetLanguage.decode(pigeonMap['language']!)
          : null,
      owner: pigeonMap['owner'] != null
          ? Owner.decode(pigeonMap['owner']!)
          : null,
      isOwner: pigeonMap['isOwner'] as bool?,
      timeAgo: pigeonMap['timeAgo'] as String?,
      voteResult: pigeonMap['voteResult'] as int?,
      userReaction: pigeonMap['userReaction'] != null
          ? UserReaction.values[pigeonMap['userReaction']! as int]
          : null,
      isPrivate: pigeonMap['isPrivate'] as bool?,
      isLiked: pigeonMap['isLiked'] as bool?,
      isDisliked: pigeonMap['isDisliked'] as bool?,
      isSaved: pigeonMap['isSaved'] as bool?,
      isToDelete: pigeonMap['isToDelete'] as bool?,
    );
  }
}

class SnippetCode {
  SnippetCode({
    this.raw,
    this.tokens,
  });

  String? raw;
  List<SyntaxToken?>? tokens;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['raw'] = raw;
    pigeonMap['tokens'] = tokens;
    return pigeonMap;
  }

  static SnippetCode decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SnippetCode(
      raw: pigeonMap['raw'] as String?,
      tokens: (pigeonMap['tokens'] as List<Object?>?)?.cast<SyntaxToken?>(),
    );
  }
}

class SyntaxToken {
  SyntaxToken({
    this.start,
    this.end,
    this.color,
  });

  int? start;
  int? end;
  int? color;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['start'] = start;
    pigeonMap['end'] = end;
    pigeonMap['color'] = color;
    return pigeonMap;
  }

  static SyntaxToken decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SyntaxToken(
      start: pigeonMap['start'] as int?,
      end: pigeonMap['end'] as int?,
      color: pigeonMap['color'] as int?,
    );
  }
}

class SnippetLanguage {
  SnippetLanguage({
    this.raw,
    this.type,
  });

  String? raw;
  SnippetLanguageType? type;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['raw'] = raw;
    pigeonMap['type'] = type?.index;
    return pigeonMap;
  }

  static SnippetLanguage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SnippetLanguage(
      raw: pigeonMap['raw'] as String?,
      type: pigeonMap['type'] != null
          ? SnippetLanguageType.values[pigeonMap['type']! as int]
          : null,
    );
  }
}

class Owner {
  Owner({
    this.id,
    this.login,
  });

  int? id;
  String? login;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['id'] = id;
    pigeonMap['login'] = login;
    return pigeonMap;
  }

  static Owner decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Owner(
      id: pigeonMap['id'] as int?,
      login: pigeonMap['login'] as String?,
    );
  }
}

class SnippetFilter {
  SnippetFilter({
    this.languages,
    this.selectedLanguages,
    this.scopes,
    this.selectedScope,
  });

  List<String?>? languages;
  List<String?>? selectedLanguages;
  List<String?>? scopes;
  String? selectedScope;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['languages'] = languages;
    pigeonMap['selectedLanguages'] = selectedLanguages;
    pigeonMap['scopes'] = scopes;
    pigeonMap['selectedScope'] = selectedScope;
    return pigeonMap;
  }

  static SnippetFilter decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SnippetFilter(
      languages: (pigeonMap['languages'] as List<Object?>?)?.cast<String?>(),
      selectedLanguages: (pigeonMap['selectedLanguages'] as List<Object?>?)?.cast<String?>(),
      scopes: (pigeonMap['scopes'] as List<Object?>?)?.cast<String?>(),
      selectedScope: pigeonMap['selectedScope'] as String?,
    );
  }
}

class MainModelStateData {
  MainModelStateData({
    this.state,
    this.is_loading,
    this.data,
    this.filter,
    this.error,
    this.oldHash,
    this.newHash,
  });

  ModelState? state;
  bool? is_loading;
  List<Snippet?>? data;
  SnippetFilter? filter;
  String? error;
  int? oldHash;
  int? newHash;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['state'] = state?.index;
    pigeonMap['is_loading'] = is_loading;
    pigeonMap['data'] = data;
    pigeonMap['filter'] = filter?.encode();
    pigeonMap['error'] = error;
    pigeonMap['oldHash'] = oldHash;
    pigeonMap['newHash'] = newHash;
    return pigeonMap;
  }

  static MainModelStateData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MainModelStateData(
      state: pigeonMap['state'] != null
          ? ModelState.values[pigeonMap['state']! as int]
          : null,
      is_loading: pigeonMap['is_loading'] as bool?,
      data: (pigeonMap['data'] as List<Object?>?)?.cast<Snippet?>(),
      filter: pigeonMap['filter'] != null
          ? SnippetFilter.decode(pigeonMap['filter']!)
          : null,
      error: pigeonMap['error'] as String?,
      oldHash: pigeonMap['oldHash'] as int?,
      newHash: pigeonMap['newHash'] as int?,
    );
  }
}

class MainModelEventData {
  MainModelEventData({
    this.event,
    this.message,
    this.oldHash,
    this.newHash,
  });

  MainModelEvent? event;
  String? message;
  int? oldHash;
  int? newHash;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['event'] = event?.index;
    pigeonMap['message'] = message;
    pigeonMap['oldHash'] = oldHash;
    pigeonMap['newHash'] = newHash;
    return pigeonMap;
  }

  static MainModelEventData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MainModelEventData(
      event: pigeonMap['event'] != null
          ? MainModelEvent.values[pigeonMap['event']! as int]
          : null,
      message: pigeonMap['message'] as String?,
      oldHash: pigeonMap['oldHash'] as int?,
      newHash: pigeonMap['newHash'] as int?,
    );
  }
}

class DetailModelStateData {
  DetailModelStateData({
    this.state,
    this.is_loading,
    this.data,
    this.error,
    this.oldHash,
    this.newHash,
  });

  ModelState? state;
  bool? is_loading;
  Snippet? data;
  String? error;
  int? oldHash;
  int? newHash;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['state'] = state?.index;
    pigeonMap['is_loading'] = is_loading;
    pigeonMap['data'] = data?.encode();
    pigeonMap['error'] = error;
    pigeonMap['oldHash'] = oldHash;
    pigeonMap['newHash'] = newHash;
    return pigeonMap;
  }

  static DetailModelStateData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return DetailModelStateData(
      state: pigeonMap['state'] != null
          ? ModelState.values[pigeonMap['state']! as int]
          : null,
      is_loading: pigeonMap['is_loading'] as bool?,
      data: pigeonMap['data'] != null
          ? Snippet.decode(pigeonMap['data']!)
          : null,
      error: pigeonMap['error'] as String?,
      oldHash: pigeonMap['oldHash'] as int?,
      newHash: pigeonMap['newHash'] as int?,
    );
  }
}

class DetailModelEventData {
  DetailModelEventData({
    this.event,
    this.value,
    this.oldHash,
    this.newHash,
  });

  DetailModelEvent? event;
  String? value;
  int? oldHash;
  int? newHash;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['event'] = event?.index;
    pigeonMap['value'] = value;
    pigeonMap['oldHash'] = oldHash;
    pigeonMap['newHash'] = newHash;
    return pigeonMap;
  }

  static DetailModelEventData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return DetailModelEventData(
      event: pigeonMap['event'] != null
          ? DetailModelEvent.values[pigeonMap['event']! as int]
          : null,
      value: pigeonMap['value'] as String?,
      oldHash: pigeonMap['oldHash'] as int?,
      newHash: pigeonMap['newHash'] as int?,
    );
  }
}

class LoginModelStateData {
  LoginModelStateData({
    this.state,
    this.is_loading,
    this.oldHash,
    this.newHash,
  });

  ModelState? state;
  bool? is_loading;
  int? oldHash;
  int? newHash;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['state'] = state?.index;
    pigeonMap['is_loading'] = is_loading;
    pigeonMap['oldHash'] = oldHash;
    pigeonMap['newHash'] = newHash;
    return pigeonMap;
  }

  static LoginModelStateData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return LoginModelStateData(
      state: pigeonMap['state'] != null
          ? ModelState.values[pigeonMap['state']! as int]
          : null,
      is_loading: pigeonMap['is_loading'] as bool?,
      oldHash: pigeonMap['oldHash'] as int?,
      newHash: pigeonMap['newHash'] as int?,
    );
  }
}

class LoginModelEventData {
  LoginModelEventData({
    this.event,
    this.oldHash,
    this.newHash,
  });

  LoginModelEvent? event;
  int? oldHash;
  int? newHash;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['event'] = event?.index;
    pigeonMap['oldHash'] = oldHash;
    pigeonMap['newHash'] = newHash;
    return pigeonMap;
  }

  static LoginModelEventData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return LoginModelEventData(
      event: pigeonMap['event'] != null
          ? LoginModelEvent.values[pigeonMap['event']! as int]
          : null,
      oldHash: pigeonMap['oldHash'] as int?,
      newHash: pigeonMap['newHash'] as int?,
    );
  }
}

class _MainModelBridgeCodec extends StandardMessageCodec{
  const _MainModelBridgeCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is MainModelEventData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is MainModelStateData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is Owner) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is Snippet) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is SnippetCode) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is SnippetFilter) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is SnippetLanguage) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
    if (value is SyntaxToken) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return MainModelEventData.decode(readValue(buffer)!);
      
      case 129:       
        return MainModelStateData.decode(readValue(buffer)!);
      
      case 130:       
        return Owner.decode(readValue(buffer)!);
      
      case 131:       
        return Snippet.decode(readValue(buffer)!);
      
      case 132:       
        return SnippetCode.decode(readValue(buffer)!);
      
      case 133:       
        return SnippetFilter.decode(readValue(buffer)!);
      
      case 134:       
        return SnippetLanguage.decode(readValue(buffer)!);
      
      case 135:       
        return SyntaxToken.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class MainModelBridge {
  /// Constructor for [MainModelBridge].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MainModelBridge({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _MainModelBridgeCodec();

  Future<MainModelStateData> getState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MainModelBridge.getState', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MainModelStateData?)!;
    }
  }

  Future<MainModelEventData> getEvent() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MainModelBridge.getEvent', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MainModelEventData?)!;
    }
  }

  Future<void> resetEvent() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MainModelBridge.resetEvent', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> initState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MainModelBridge.initState', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> filterLanguage(String arg_language, bool arg_isSelected) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MainModelBridge.filterLanguage', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_language, arg_isSelected]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> filterScope(String arg_scope) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MainModelBridge.filterScope', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_scope]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> logOut() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MainModelBridge.logOut', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _DetailModelBridgeCodec extends StandardMessageCodec{
  const _DetailModelBridgeCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is DetailModelEventData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is DetailModelStateData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is Owner) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is Snippet) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is SnippetCode) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is SnippetLanguage) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is SyntaxToken) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return DetailModelEventData.decode(readValue(buffer)!);
      
      case 129:       
        return DetailModelStateData.decode(readValue(buffer)!);
      
      case 130:       
        return Owner.decode(readValue(buffer)!);
      
      case 131:       
        return Snippet.decode(readValue(buffer)!);
      
      case 132:       
        return SnippetCode.decode(readValue(buffer)!);
      
      case 133:       
        return SnippetLanguage.decode(readValue(buffer)!);
      
      case 134:       
        return SyntaxToken.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class DetailModelBridge {
  /// Constructor for [DetailModelBridge].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  DetailModelBridge({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _DetailModelBridgeCodec();

  Future<DetailModelStateData> getState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.getState', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as DetailModelStateData?)!;
    }
  }

  Future<DetailModelEventData> getEvent() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.getEvent', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as DetailModelEventData?)!;
    }
  }

  Future<void> resetEvent() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.resetEvent', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> load(String arg_uuid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.load', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_uuid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> like() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.like', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> dislike() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.dislike', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> save() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.save', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> copyToClipboard() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.copyToClipboard', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> share() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.share', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> delete() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DetailModelBridge.delete', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _LoginModelBridgeCodec extends StandardMessageCodec{
  const _LoginModelBridgeCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is LoginModelEventData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is LoginModelStateData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return LoginModelEventData.decode(readValue(buffer)!);
      
      case 129:       
        return LoginModelStateData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class LoginModelBridge {
  /// Constructor for [LoginModelBridge].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  LoginModelBridge({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _LoginModelBridgeCodec();

  Future<LoginModelStateData> getState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LoginModelBridge.getState', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as LoginModelStateData?)!;
    }
  }

  Future<LoginModelEventData> getEvent() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LoginModelBridge.getEvent', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as LoginModelEventData?)!;
    }
  }

  Future<void> loginOrRegister(String arg_email, String arg_password) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LoginModelBridge.loginOrRegister', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_email, arg_password]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> checkLoginState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LoginModelBridge.checkLoginState', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> resetEvent() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LoginModelBridge.resetEvent', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}
